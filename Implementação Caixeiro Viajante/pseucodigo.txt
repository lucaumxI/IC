float custo(int v[], int** matrizCusto){                                  
    float soma = 0;      //O(1)
    for (int cidadeAtual = 0; cidadeAtual < tamanho ; cidadeAtual++){      //O(n)
        soma += matrizCusto[v[cidadeAtual]][v[cidadeAtual + 1]];           ////O(1)
    }

    return soma;        
}        //limitada superiormente por O(n)


void swap(int* v, int posA, int posB){      
    int aux = v[posA];       //O(1)               
    v[posA] = v[posB];      //O(1) 
    v[posB] = aux;          //O(1) 
}      //O(1) 


//Pior caso seria quando tivesse que inverter de 1 até (tamanho - 1)
void inverse(int* v, int posA, int posB){  
    int aux;                     //O(1)          
    if(posA<posB){
        for(posA; posA<posB; posA++){      //esse laço, no pior caso começa no 1 e vai até metade do vetor, pois ao passo que posA incrementa o posB decrementa, até se "encontrarem no meio", portanto O(n/2)
            aux = v[posA];                //O(1)
            v[posA] = v[posB];            //O(1)
            v[posB] = aux;                //O(1)
            posB--;                       //O(1)
        }
    }
    else{                                //mesma coisa do laço de cima só muda que ao inves de "percorrer o vetor pra direita" se "percorre indo pra esquerda"
        for(posB; posB<posA; posB++){
            aux = v[posA];
            v[posA] = v[posB];
            v[posB] = aux;
            posA--;
        }
    }
}//O(n/2)

void insert(int* v, int posA, int posB){  //pior caso seria tirar um elemento de alguma extremidade do vetor e coloca-lo na outra, pois seria necessario reorganizar o vetor inteiro    
    int aux;                            //O(1)

    aux = v[posA];    //O(1)

    if(posA < posB){    //O(1)
        for(int i = posA; i<posB; i++){    //O(n)
            v[i] = v[i + 1];        //O(1)
        }
        v[posB] = aux;
    }
    else{
        for(int i = posA; i>posB; i--){    //mesma coisa do laço de cima
            v[i] = v[i - 1];
        }
        v[posB] = aux;
    }


}    //O(n)


void changeSolution(int* v, int posA, int posB){   //não sei analisar complexidade disso
    int func = rand() % 3;

    switch(func){
        case 0:
            inverse(v, posA, posB);
            break;
        case 1:
            swap(v, posA, posB);
            break;
        case 2:
            insert(v, posA, posB);
            break;
    }

}



float comparacao(int* v, int* possivelEstado, int** matrizCusto){           
    return custo(possivelEstado, matrizCusto) - custo(v, matrizCusto); //2 * O(n) + O(1)
} //O(n)

float probabilidadeAceitar(float temp, float deltaC){                      
    return (exp(-1* deltaC / temp));      //O(1)
} //O(1)
